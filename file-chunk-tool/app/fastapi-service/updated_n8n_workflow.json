{
  "name": "Audio Notes with File Chunking",
  "nodes": [
    {
      "parameters": {
        "pollTimes": {
          "item": [
            {
              "mode": "everyMinute"
            }
          ]
        },
        "triggerOn": "specificFolder",
        "folderToWatch": {
          "__rl": true,
          "value": "https://drive.google.com/drive/u/0/folders/1J0a7oleiyDbVY_9crAcbaXec0Uxb4x2E",
          "mode": "url"
        },
        "event": "fileCreated",
        "options": {}
      },
      "name": "Google Drive Trigger",
      "type": "n8n-nodes-base.googleDriveTrigger",
      "typeVersion": 1,
      "position": [
        -200,
        0
      ],
      "id": "google-drive-trigger"
    },
    {
      "parameters": {
        "url": "=https://www.googleapis.com/drive/v3/files/{{ $json[\"id\"] }}?alt=media",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "googleDriveOAuth2Api",
        "options": {}
      },
      "name": "Download File",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        0,
        0
      ],
      "id": "download-file"
    },
    {
      "parameters": {
        "jsCode": "const fileSizeKb = $json.size / 1024;\nconst estimatedDurationMin = fileSizeKb / 200;\nconst costPerMin = 0.006;\n\nreturn [{\n  json: {\n    filename: $json.name || 'Unknown',\n    estimated_duration_minutes: parseFloat(estimatedDurationMin.toFixed(2)),\n    duration_seconds: Math.round(estimatedDurationMin * 60),\n    cost: parseFloat((estimatedDurationMin * costPerMin).toFixed(4)),\n    token_count: 0,\n    file_size_mb: parseFloat((Number($json.size) / 1000000).toFixed(2))\n  }\n}];"
      },
      "name": "Calculate Metadata",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        200,
        0
      ],
      "id": "calculate-metadata"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "version": 2,
          "conditions": [
            {
              "id": "file-size-check",
              "leftValue": "={{ $json.file_size_mb }}",
              "rightValue": 25,
              "operator": {
                "type": "number",
                "operation": "gte"
              },
              "combinator": "and"
            }
          ]
        },
        "options": {}
      },
      "name": "Check File Size",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        400,
        0
      ],
      "id": "check-file-size"
    },
    {
      "parameters": {
        "url": "http://fastapi-service:8000/upload",
        "method": "POST",
        "sendBinaryData": true,
        "binaryPropertyName": "data",
        "options": {}
      },
      "name": "Send to Chunker",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        600,
        -100
      ],
      "id": "send-to-chunker"
    },
    {
      "parameters": {
        "mode": "jsonToBinary",
        "sourceKey": "json.chunks",
        "options": {}
      },
      "name": "Extract Chunks",
      "type": "n8n-nodes-base.moveData",
      "typeVersion": 1,
      "position": [
        800,
        -100
      ],
      "id": "extract-chunks"
    },
    {
      "parameters": {
        "batchSize": 1
      },
      "name": "Process Each Chunk",
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 1,
      "position": [
        1000,
        -100
      ],
      "id": "process-each-chunk"
    },
    {
      "parameters": {
        "resource": "audio",
        "operation": "transcribe",
        "binaryPropertyName": "=data",
        "options": {}
      },
      "name": "Transcribe Chunk",
      "type": "@n8n/n8n-nodes-langchain.openAi",
      "typeVersion": 1.8,
      "position": [
        1200,
        -100
      ],
      "id": "transcribe-chunk"
    },
    {
      "parameters": {
        "mode": "combine",
        "combinationMode": "multiplex",
        "options": {}
      },
      "name": "Combine Transcriptions",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 2,
      "position": [
        1400,
        -100
      ],
      "id": "combine-transcriptions"
    },
    {
      "parameters": {
        "jsCode": "// Combine all transcriptions into a single text\nconst transcriptions = items.map(item => item.json.text);\nreturn [{\n  json: {\n    text: transcriptions.join(' '),\n    original_filename: $node[\"Download File\"].json.name,\n    chunks_count: $node[\"Send to Chunker\"].json.num_chunks || 1\n  }\n}];"
      },
      "name": "Merge Transcriptions",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        1600,
        -100
      ],
      "id": "merge-transcriptions"
    },
    {
      "parameters": {
        "resource": "audio",
        "operation": "transcribe",
        "binaryPropertyName": "=data",
        "options": {}
      },
      "name": "Direct Transcription",
      "type": "@n8n/n8n-nodes-langchain.openAi",
      "typeVersion": 1.8,
      "position": [
        600,
        100
      ],
      "id": "direct-transcription"
    },
    {
      "parameters": {},
      "name": "Merge Results",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.1,
      "position": [
        1800,
        0
      ],
      "id": "merge-results"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=Respond using only the `format_final_json_response` tool.\nSystem: You are a structured-output AI. You MUST use the tool `format_final_json_response` to return your final output. Do not describe the format. Do not return the schema. Do not output anything else. Only use this tool once you are ready to respond.\n\nHuman: You are a meeting summarizer AI. Given this meeting transcript, extract structured JSON using this tool.\n\nUse this:\n\nTool: format_final_json_response  \nParameters:\n{\n  \"title\": \"Concise title of the meeting\",\n  \"summary\": \"Brief summary of the meeting in 2â€“3 sentences.\",\n  \"transcript\": \"Cleaned-up transcript text\",\n  \"main_points\": [\"Point 1\", \"Point 2\", \"Point 3\"],\n  \"potential_action_items\": [\"Action 1\", \"Action 2\"],\n  \"arguments\": [\n    {\n      \"topic\": \"Issue discussed\",\n      \"position\": \"Position taken\",\n      \"justification\": \"Rationale\"\n    }\n  ],\n  \"attendees\": [\"Name1\", \"Name2\"],\n  \"cost\": 0.00,\n  \"duration_seconds\": 0,\n  \"token_count\": 0\n}\n\nTranscript:\n{{ $json['text'] }}\n\nRespond using only the `format_final_json_response` tool.",
        "hasOutputParser": true,
        "options": {}
      },
      "name": "AI Agent",
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 1.9,
      "position": [
        2000,
        0
      ],
      "id": "ai-agent"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "mode": "list",
          "value": "gpt-4o-mini"
        },
        "options": {}
      },
      "name": "OpenAI Chat Model",
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        2000,
        200
      ],
      "id": "openai-chat-model"
    },
    {
      "parameters": {
        "jsCode": "const result = JSON.parse($json.output || '{}');\n\n// Ensure required fields are always present\nresult.attendees = Array.isArray(result.attendees) ? result.attendees : [];\nresult.summary = result.summary || 'N/A';\nresult.transcript = result.transcript || 'N/A';\nresult.main_points = result.main_points || [];\nresult.potential_action_items = result.potential_action_items || [];\nresult.stories_and_examples = result.stories_and_examples || 'N/A';\nresult.references_and_citations = result.references_and_citations || 'N/A';\nresult.arguments = result.arguments || [];\nresult.cost = result.cost || 0;\nresult.duration_seconds = result.duration_seconds || 0;\nresult.token_count = result.token_count || 0;\n\nreturn [{ json: result }];"
      },
      "name": "Parse Output",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2200,
        0
      ],
      "id": "parse-output"
    },
    {
      "parameters": {
        "jsCode": "const summary = $json.summary ?? 'N/A';\nconst transcript = $json.transcript ?? 'N/A';\nconst mainPoints = Array.isArray($json.main_points) ? $json.main_points : [];\nconst actionItems = Array.isArray($json.potential_action_items) ? $json.potential_action_items : [];\nconst argumentsList = Array.isArray($json.arguments) ? $json.arguments : [];\nconst attendees = Array.isArray($json.attendees) ? $json.attendees.join(', ') : 'N/A';\n\nlet md = `### Summary\\n${summary}\\n\\n`;\n\nmd += `### Transcript\\n${transcript}\\n\\n`;\n\nmd += `### Main Points\\n`;\nmd += mainPoints.length ? `- ${mainPoints.join('\\n- ')}\\n\\n` : 'N/A\\n\\n';\n\nmd += `### Potential Action Items\\n`;\nmd += actionItems.length ? `- ${actionItems.join('\\n- ')}\\n\\n` : 'N/A\\n\\n';\n\nmd += `### Arguments and Areas for Improvement\\n`;\nif (argumentsList.length) {\n  for (const arg of argumentsList) {\n    md += `- **${arg.topic}**: ${arg.position} _(Justification: ${arg.justification})_\\n`;\n  }\n} else {\n  md += 'N/A\\n';\n}\n\nmd += `\\n### Attendees\\n${attendees}\\n\\n`;\n\nreturn [{\n  json: {\n    ...$json,\n    full_markdown: md\n  }\n}];"
      },
      "name": "Format to Markdown",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2400,
        0
      ],
      "id": "format-to-markdown"
    },
    {
      "parameters": {
        "jsCode": "const title = $json.title ?? $input.item(0)?.json?.title ?? 'Untitled';\nconst attendees = Array.isArray($json.attendees) ? $json.attendees.join(', ') : 'N/A';\nconst webLink = $json.webViewLink || $json.url || null;\n\nreturn [{\n  json: {\n    // Cleaned & normalized fields\n    title,\n    filename: $json.filename || 'Unknown',\n    transcript: $json.transcript || '',\n    summary: $json.summary || '',\n    cost: $json.cost ?? 0,\n    duration_seconds: $json.duration_seconds ?? 0,\n    estimated_duration_minutes: $json.estimated_duration_minutes ?? 0,\n    token_count: $json.token_count ?? 0,\n    webViewLink: webLink,\n    attendees,\n    full_markdown: $json.full_markdown || '',\n\n    // Required Notion-formatted field\n    notionFormattedTitle: {\n      title: [\n        {\n          text: {\n            content: title\n          }\n        }\n      ]\n    }\n  }\n}];"
      },
      "name": "Prepare for Notion",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2600,
        0
      ],
      "id": "prepare-for-notion"
    },
    {
      "parameters": {
        "resource": "databasePage",
        "databaseId": {
          "__rl": true,
          "value": "8ed80b06-db89-40ba-b076-24872c59bb59",
          "mode": "list",
          "cachedResultName": "All Notes [UB]",
          "cachedResultUrl": "https://www.notion.so/8ed80b06db8940bab07624872c59bb59"
        },
        "title": "={{ $json.title }}",
        "propertiesUi": {
          "propertyValues": [
            {
              "key": "URL|url",
              "urlValue": "={{ $json.webViewLink }}\n"
            },
            {
              "key": "Duration (Seconds)|number",
              "numberValue": "={{ $json.duration_seconds }}"
            },
            {
              "key": "AI Cost|number",
              "numberValue": "={{ $json.cost }}"
            },
            {
              "key": "Attendees|rich_text",
              "textContent": "={{ $json.attendees }}"
            }
          ]
        },
        "options": {}
      },
      "name": "Create Notion Page",
      "type": "n8n-nodes-base.notion",
      "typeVersion": 2.2,
      "position": [
        2800,
        0
      ],
      "id": "create-notion-page"
    },
    {
      "parameters": {
        "jsCode": "return [\n  {\n    json: {\n      notion_id: $node[\"Create Notion Page\"].json.id,\n      markdown: $node[\"Prepare for Notion\"].json.full_markdown\n    }\n  }\n];"
      },
      "name": "Get Notion ID",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3000,
        0
      ],
      "id": "get-notion-id"
    },
    {
      "parameters": {
        "jsCode": "// Get markdown from the input data\nlet markdown = $json.markdown || '';\n\n// Validate that we have a string\nif (typeof markdown !== 'string') {\n  return [{ json: { \n    children: [{\n      object: \"block\",\n      type: \"paragraph\", \n      paragraph: {\n        rich_text: [{\n          type: \"text\",\n          text: { content: \"Markdown content is not a valid string\" }\n        }]\n      }\n    }]\n  }}];\n}\n\nconst lines = markdown.split('\\n');\nconst blocks = [];\n\nlet currentContent = '';\n\nfor (let i = 0; i < lines.length; i++) {\n  const line = lines[i].trim();\n  \n  if (line.startsWith('### ')) {\n    // Add previous content if exists\n    if (currentContent.trim()) {\n      blocks.push({\n        object: \"block\",\n        type: \"paragraph\",\n        paragraph: {\n          rich_text: [{\n            type: \"text\",\n            text: { content: currentContent.trim() }\n          }]\n        }\n      });\n      currentContent = '';\n    }\n    \n    // Add heading\n    const headingText = line.replace('### ', '');\n    blocks.push({\n      object: \"block\",\n      type: \"heading_3\",\n      heading_3: {\n        rich_text: [{\n          type: \"text\", \n          text: { content: headingText }\n        }]\n      }\n    });\n  } else if (line.startsWith('- ')) {\n    // Add previous content if exists\n    if (currentContent.trim()) {\n      blocks.push({\n        object: \"block\",\n        type: \"paragraph\",\n        paragraph: {\n          rich_text: [{\n            type: \"text\",\n            text: { content: currentContent.trim() }\n          }]\n        }\n      });\n      currentContent = '';\n    }\n    \n    // Add bullet point\n    const bulletText = line.replace('- ', '');\n    if (bulletText.startsWith('**') && bulletText.includes('**:')) {\n      // Handle formatted bullet points like \"**Topic**: Content _(Justification: text)_\"\n      const parts = bulletText.split('**:');\n      const boldPart = parts[0].replace('**', '');\n      const restPart = parts[1] || '';\n      \n      blocks.push({\n        object: \"block\",\n        type: \"bulleted_list_item\",\n        bulleted_list_item: {\n          rich_text: [\n            {\n              type: \"text\",\n              text: { content: boldPart },\n              annotations: { bold: true }\n            },\n            {\n              type: \"text\",\n              text: { content: ': ' + restPart }\n            }\n          ]\n        }\n      });\n    } else {\n      blocks.push({\n        object: \"block\",\n        type: \"bulleted_list_item\", \n        bulleted_list_item: {\n          rich_text: [{\n            type: \"text\",\n            text: { content: bulletText }\n          }]\n        }\n      });\n    }\n  } else if (line === 'N/A') {\n    // Handle N/A entries\n    blocks.push({\n      object: \"block\",\n      type: \"paragraph\",\n      paragraph: {\n        rich_text: [{\n          type: \"text\",\n          text: { content: \"N/A\" },\n          annotations: { italic: true }\n        }]\n      }\n    });\n  } else if (line.length > 0) {\n    // Regular content line\n    currentContent += line + '\\n';\n  } else if (currentContent.trim()) {\n    // Empty line - add accumulated content as paragraph\n    blocks.push({\n      object: \"block\",\n      type: \"paragraph\",\n      paragraph: {\n        rich_text: [{\n          type: \"text\",\n          text: { content: currentContent.trim() }\n        }]\n      }\n    });\n    currentContent = '';\n  }\n}\n\n// Add any remaining content\nif (currentContent.trim()) {\n  blocks.push({\n    object: \"block\",\n    type: \"paragraph\",\n    paragraph: {\n      rich_text: [{\n        type: \"text\",\n        text: { content: currentContent.trim() }\n      }]\n    }\n  });\n}\n\nreturn [{ \n  json: { \n    children: blocks,\n    notion_id: $json.notion_id\n  } \n}];"
      },
      "name": "Format Notion Blocks",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3200,
        0
      ],
      "id": "format-notion-blocks"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://api.notion.com/v1/blocks/{{ $json.notion_id }}/children",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "notionApi",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Notion-Version",
              "value": "2022-06-28"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "children",
              "value": "={{ $json.children }}"
            }
          ]
        },
        "options": {}
      },
      "name": "Add Content to Notion",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        3400,
        0
      ],
      "id": "add-content-to-notion"
    }
  ],
  "connections": {
    "Google Drive Trigger": {
      "main": [
        [
          {
            "node": "Download File",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Download File": {
      "main": [
        [
          {
            "node": "Calculate Metadata",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Calculate Metadata": {
      "main": [
        [
          {
            "node": "Check File Size",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check File Size": {
      "main": [
        [
          {
            "node": "Send to Chunker",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Direct Transcription",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Send to Chunker": {
      "main": [
        [
          {
            "node": "Extract Chunks",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Chunks": {
      "main": [
        [
          {
            "node": "Process Each Chunk",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process Each Chunk": {
      "main": [
        [
          {
            "node": "Transcribe Chunk",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Transcribe Chunk": {
      "main": [
        [
          {
            "node": "Combine Transcriptions",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Combine Transcriptions": {
      "main": [
        [
          {
            "node": "Merge Transcriptions",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge Transcriptions": {
      "main": [
        [
          {
            "node": "Merge Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Direct Transcription": {
      "main": [
        [
          {
            "node": "Merge Results",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Merge Results": {
      "main": [
        [
          {
            "node": "AI Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model": {
      "ai_languageModel": [
        [
          {
            "node": "AI Agent",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "AI Agent": {
      "main": [
        [
          {
            "node": "Parse Output",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Output": {
      "main": [
        [
          {
            "node": "Format to Markdown",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format to Markdown": {
      "main": [
        [
          {
            "node": "Prepare for Notion",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare for Notion": {
      "main": [
        [
          {
            "node": "Create Notion Page",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Create Notion Page": {
      "main": [
        [
          {
            "node": "Get Notion ID",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Notion ID": {
      "main": [
        [
          {
            "node": "Format Notion Blocks",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format Notion Blocks": {
      "main": [
        [
          {
            "node": "Add Content to Notion",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  }
}